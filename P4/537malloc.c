/* author1: Dasong Gao
 * author2: Haozhe Luo
 */

#include "537malloc.h"

#include "autoarr.h"
#include "memavl.h"
#include "stdinclude.h"
#include "utils.h"

static mem_node *root = NULL;
static const int BT_MAX_DEPTH = 10;

// get stacktrace without the several deepest frames
char **getst(int *pnst, int off);

// prints the stack trace generated by getst()
void printst(char **st, int nst);

// print stack trace before exits
void die_st(int off);

// NB: only call this on c/malloc'ed ptr
static mem_node *malloc_helper(void *ptr, size_t size) {
	// resolve any overlap of previously freed block
	ASARR_INIT(overlap, mem_node*);
	find_overlap(root, ptr, size, overlap);
	mem_node **arr = ASARR_GET(overlap);
	for (int i = 0; i < ASARR_SIZE(overlap); i++) {
		// memory must be freed by now
		if (arr[i]->interval.start < ptr) {
			// case 1: first half not overlap, second half contains overlap
			arr[i]->interval.end = ptr;
		}
		else {
			// case 2: start of node is within the newly allocated mem
			PEONN(ndel, arr[i], &root);
		}
	}
	mem_node *node = ncreate(ptr, size, 0, 0, NULL);
	PEONN(nadd, node, &root);
	ASARR_DESTROY(overlap);
	return node;
}

static mem_node *free_check(void *ptr) {
	ASARR_INIT(overlap, mem_node *);
	find_overlap(root, ptr, 0, overlap);
	if (ASARR_SIZE(overlap) == 0) {
		fprintf(stderr, "Error: freeing unallocated block at %p\n", ptr);
		die_st(3);
	}
	mem_node *node = ASARR_GET(overlap)[0];
	ASARR_DESTROY(overlap);
	if (node->interval.start != ptr) {
		fprintf(stderr, 
			"Error: freeing %p in the middle of an allocated block at %p\n",
			ptr, node->interval.start);
		die_st(3);
	}
	if (node->interval.isfree == 1) {
		fprintf(stderr, "Error: Freeing an already freed block at %p\nPreviously freed at:\n", ptr);
		printst(node->interval.st, node->interval.nst);
		die_st(3);
	}
	return node;
}

void *malloc537(size_t size) {
	if (size == 0) {
		fprintf(stderr, "Warning: mallocing a block of size 0\n");
	}
	void *ptr = PEONZ(malloc, size);
	mem_node *node = malloc_helper(ptr, size);
	node->interval.st = getst(&node->interval.nst, 1);
	return ptr;
}

void free537(void *ptr) {
	if (ptr == NULL)
		return;
	mem_node *node = free_check(ptr);
	node->interval.isfree = 1;
	node->interval.st = getst(&node->interval.nst, 1);
	free(ptr);
}

void *realloc537(void *ptr, size_t size) {
	if (ptr == NULL)
		return malloc537(size);
	if (size == 0) {
		fprintf(stderr, "Warning: reallocing the block %p to size 0"
				" is equivalant to freeing it\n", ptr);
		free537(ptr);
		return NULL;
	}
	mem_node *node = free_check(ptr);
	void *ret = PEONZ(realloc, ptr, size);

	// no need to go through the expensive add/delete
	if (ret == ptr)
		node->interval.end = ptr + size;
	else {
		PEONN(ndel, node, &root);
		node = malloc_helper(ret, size);
	}
	node->interval.st = getst(&node->interval.nst, 1);
	return ret;
}

void memcheck537(void *ptr, size_t size) {
	ASARR_INIT(overlap, mem_node*);
	find_overlap(root, ptr, size, overlap);
	if (ASARR_SIZE(overlap) != 1) {
		fprintf(stderr, "Error: Invalid memory access\n");
		die_st(3);
	}
	mem_i interval = ASARR_GET(overlap)[0]->interval;
	if (interval.start <= ptr && interval.end >= ptr + size) {
		if (interval.isfree == 1) {
			fprintf(stderr, "Error: Access of freed memory of block at %p\n",
					interval.start);
			fprintf(stderr, "Previously freed at:\n");
			printst(interval.st, interval.nst);
			die_st(3);
		}
	}
	else {
		fprintf(stderr, "Error: Out-of-bound access of block at %p\n",
				interval.start);
		fprintf(stderr, "Previously allocated at:\n");
		printst(interval.st, interval.nst);
		die_st(3);
	}
	ASARR_DESTROY(overlap);
}

char **getst(int *pnst, int off) {
	void *stack_frame[BT_MAX_DEPTH];
	int nst = backtrace(stack_frame, BT_MAX_DEPTH);
	if (pnst) *pnst = nst - off;
	char **framestrings = backtrace_symbols(stack_frame, nst);
	char **ret = framestrings;
	if (off != 0) {
		ret = calloc((nst - off), sizeof(char *));
		for (int i = off; i < nst; i++)
			ret[i - off] = framestrings[i];
		free(framestrings);
	}
	return ret;
}

void printst(char **st, int nst) {
	for (int i = 0; i < nst; i++) {
		fprintf(stderr, "\t %s\n", st[i]);
	}
}

void die_st(int off) {
	fprintf(stderr, "Stacktrace:\n");
	int nst = 0;
	char **st = getst(&nst, off);
	printst(st, nst);
	free(st);
	exit(-1);
}
